<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Chombo_4: ParmParse Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Chombo_4
   &#160;<span id="projectnumber">4586</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classParmParse-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ParmParse Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Parse Parameters From Command Line and Input Files.  
 <a href="classParmParse.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Chombo__ParmParse_8H_source.html">Chombo_ParmParse.H</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a112bc7438b5cb251cbd2fdb332710886"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a112bc7438b5cb251cbd2fdb332710886">ParmParse</a> (int argc, char **argv, const char *<a class="el" href="classParmParse.html#a60c8ae7af9fe67a508e1f684439395d0">prefix</a>=0, const char *parfile=0)</td></tr>
<tr class="separator:a112bc7438b5cb251cbd2fdb332710886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1354bd11521da872dbb032377f26f9d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a1354bd11521da872dbb032377f26f9d3">define</a> (int argc, char **argv, const char *<a class="el" href="classParmParse.html#a60c8ae7af9fe67a508e1f684439395d0">prefix</a>=0, const char *parfile=0)</td></tr>
<tr class="memdesc:a1354bd11521da872dbb032377f26f9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize after calling the default constructor.  <a href="#a1354bd11521da872dbb032377f26f9d3">More...</a><br /></td></tr>
<tr class="separator:a1354bd11521da872dbb032377f26f9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adab381569c0fce8a66af5d94665421"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a6adab381569c0fce8a66af5d94665421">ParmParse</a> (const char *<a class="el" href="classParmParse.html#a60c8ae7af9fe67a508e1f684439395d0">prefix</a>=0)</td></tr>
<tr class="separator:a6adab381569c0fce8a66af5d94665421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967f6fdbdab413dbeac7de43513dce36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a967f6fdbdab413dbeac7de43513dce36">ParmParse</a> (const std::string &amp;a_string)</td></tr>
<tr class="memdesc:a967f6fdbdab413dbeac7de43513dce36"><td class="mdescLeft">&#160;</td><td class="mdescRight">got sick of typing c_str()  <a href="#a967f6fdbdab413dbeac7de43513dce36">More...</a><br /></td></tr>
<tr class="separator:a967f6fdbdab413dbeac7de43513dce36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4b6164fe6e1fd2e73aed7efb249e03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#afa4b6164fe6e1fd2e73aed7efb249e03">~ParmParse</a> ()</td></tr>
<tr class="separator:afa4b6164fe6e1fd2e73aed7efb249e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961167fcaa1cb8c018319298a7d5033f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a961167fcaa1cb8c018319298a7d5033f">contains</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>) const</td></tr>
<tr class="separator:a961167fcaa1cb8c018319298a7d5033f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029352410364963f7a85fa9f09bebe6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a029352410364963f7a85fa9f09bebe6a">contains</a> (const std::string &amp;<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>) const</td></tr>
<tr class="separator:a029352410364963f7a85fa9f09bebe6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220146c4702c0ffc06dc9d8a00605b35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a220146c4702c0ffc06dc9d8a00605b35">countval</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, int n=-1) const</td></tr>
<tr class="separator:a220146c4702c0ffc06dc9d8a00605b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3e241a4bc7eba217eab34f004f67e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#aac3e241a4bc7eba217eab34f004f67e8">countname</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>) const</td></tr>
<tr class="separator:aac3e241a4bc7eba217eab34f004f67e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc02bc16259ded5d8fc506397bdc3be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a9cc02bc16259ded5d8fc506397bdc3be">countname</a> (const std::string &amp;<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>) const</td></tr>
<tr class="separator:a9cc02bc16259ded5d8fc506397bdc3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362e72bf2e474db7a825f512f09ea7f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a362e72bf2e474db7a825f512f09ea7f2">addEntries</a> (const std::string &amp;strEntry)</td></tr>
<tr class="separator:a362e72bf2e474db7a825f512f09ea7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7078b192b4d35c4f337e47c0082b19d6"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a7078b192b4d35c4f337e47c0082b19d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParmParse.html#a7078b192b4d35c4f337e47c0082b19d6">setVal</a> (const std::string &amp;varName, TYPE varVal)</td></tr>
<tr class="separator:a7078b192b4d35c4f337e47c0082b19d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c3b0ce9c95f54033ebf8a803c3f9e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a11c3b0ce9c95f54033ebf8a803c3f9e1">setStr</a> (const std::string &amp;varName, std::string varVal)</td></tr>
<tr class="separator:a11c3b0ce9c95f54033ebf8a803c3f9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88dd5a3e4c26b11e4e02848aae8db5aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a88dd5a3e4c26b11e4e02848aae8db5aa">dumpTable</a> (std::ostream &amp;os) const</td></tr>
<tr class="separator:a88dd5a3e4c26b11e4e02848aae8db5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd67cc36c06ef22ff2f82511aebb775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a3cd67cc36c06ef22ff2f82511aebb775">get</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, int &amp;ref, int ival=0) const</td></tr>
<tr class="memdesc:a3cd67cc36c06ef22ff2f82511aebb775"><td class="mdescLeft">&#160;</td><td class="mdescRight">access single object  <a href="#a3cd67cc36c06ef22ff2f82511aebb775">More...</a><br /></td></tr>
<tr class="separator:a3cd67cc36c06ef22ff2f82511aebb775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20debc979cb3423e95a47456144632b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#ab20debc979cb3423e95a47456144632b">query</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, int &amp;ref, int ival=0) const</td></tr>
<tr class="separator:ab20debc979cb3423e95a47456144632b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e3ae744edfdae799c323cd9fa535fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#ab0e3ae744edfdae799c323cd9fa535fa">get</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, unsigned long &amp;ref, int ival=0) const</td></tr>
<tr class="memdesc:ab0e3ae744edfdae799c323cd9fa535fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">access single object  <a href="#ab0e3ae744edfdae799c323cd9fa535fa">More...</a><br /></td></tr>
<tr class="separator:ab0e3ae744edfdae799c323cd9fa535fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad49a66379d779de65ec5b5a369d260"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a4ad49a66379d779de65ec5b5a369d260">query</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, unsigned long &amp;ref, int ival=0) const</td></tr>
<tr class="separator:a4ad49a66379d779de65ec5b5a369d260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e8996d798a3e595802d7c865b47d3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a78e8996d798a3e595802d7c865b47d3d">get</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, float &amp;ref, int ival=0) const</td></tr>
<tr class="separator:a78e8996d798a3e595802d7c865b47d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164719e0ea3328d2b47c1da70e926975"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a164719e0ea3328d2b47c1da70e926975">query</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, float &amp;ref, int ival=0) const</td></tr>
<tr class="separator:a164719e0ea3328d2b47c1da70e926975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a235d4051cfc27d34fe9619658f80ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a6a235d4051cfc27d34fe9619658f80ca">get</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, double &amp;ref, int ival=0) const</td></tr>
<tr class="separator:a6a235d4051cfc27d34fe9619658f80ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76912c5c14c363ad037eefbdef990c5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a76912c5c14c363ad037eefbdef990c5a">query</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, double &amp;ref, int ival=0) const</td></tr>
<tr class="separator:a76912c5c14c363ad037eefbdef990c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84d76469c5ad1371270f460858ebcdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#af84d76469c5ad1371270f460858ebcdc">get</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::string &amp;ref, int ival=0) const</td></tr>
<tr class="memdesc:af84d76469c5ad1371270f460858ebcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ival'th value of last occurrence of the requested name.  <a href="#af84d76469c5ad1371270f460858ebcdc">More...</a><br /></td></tr>
<tr class="separator:af84d76469c5ad1371270f460858ebcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e557349f66d11a6d44fdbd0b5f3756"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#ac0e557349f66d11a6d44fdbd0b5f3756">query</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::string &amp;ref, int ival=0) const</td></tr>
<tr class="memdesc:ac0e557349f66d11a6d44fdbd0b5f3756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ival'th value of last occurrence of the requested name.  <a href="#ac0e557349f66d11a6d44fdbd0b5f3756">More...</a><br /></td></tr>
<tr class="separator:ac0e557349f66d11a6d44fdbd0b5f3756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ea98d11d58450efc84d69eccd17f81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#ad8ea98d11d58450efc84d69eccd17f81">get</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, bool &amp;ref, int ival=0) const</td></tr>
<tr class="memdesc:ad8ea98d11d58450efc84d69eccd17f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ival'th value of last occurrence of the requested name.  <a href="#ad8ea98d11d58450efc84d69eccd17f81">More...</a><br /></td></tr>
<tr class="separator:ad8ea98d11d58450efc84d69eccd17f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76e4c10ab679ae25df9d3c55054f1fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#ab76e4c10ab679ae25df9d3c55054f1fd">query</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, bool &amp;ref, int ival=0) const</td></tr>
<tr class="memdesc:ab76e4c10ab679ae25df9d3c55054f1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ival'th value of last occurrence of the requested name.  <a href="#ab76e4c10ab679ae25df9d3c55054f1fd">More...</a><br /></td></tr>
<tr class="separator:ab76e4c10ab679ae25df9d3c55054f1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfb577917bc17e952fa0c64608fa688"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a0bfb577917bc17e952fa0c64608fa688">getarr</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::vector&lt; int &gt; &amp;ref, int start_ix, int num_val) const</td></tr>
<tr class="memdesc:a0bfb577917bc17e952fa0c64608fa688"><td class="mdescLeft">&#160;</td><td class="mdescRight">access an array of objects  <a href="#a0bfb577917bc17e952fa0c64608fa688">More...</a><br /></td></tr>
<tr class="separator:a0bfb577917bc17e952fa0c64608fa688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd5b0a97ebf1ed742a4e5d1d6b981aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a4bd5b0a97ebf1ed742a4e5d1d6b981aa">queryarr</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::vector&lt; int &gt; &amp;ref, int start_ix, int num_val) const</td></tr>
<tr class="memdesc:a4bd5b0a97ebf1ed742a4e5d1d6b981aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">access an array of objects  <a href="#a4bd5b0a97ebf1ed742a4e5d1d6b981aa">More...</a><br /></td></tr>
<tr class="separator:a4bd5b0a97ebf1ed742a4e5d1d6b981aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f68fc1255e45095978ab54eb726c9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a45f68fc1255e45095978ab54eb726c9f">getarr</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::vector&lt; unsigned long &gt; &amp;ref, int start_ix, int num_val) const</td></tr>
<tr class="memdesc:a45f68fc1255e45095978ab54eb726c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">access an array of objects  <a href="#a45f68fc1255e45095978ab54eb726c9f">More...</a><br /></td></tr>
<tr class="separator:a45f68fc1255e45095978ab54eb726c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c3848fa91eeb33288096bd0702c437"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a96c3848fa91eeb33288096bd0702c437">queryarr</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::vector&lt; unsigned long &gt; &amp;ref, int start_ix, int num_val) const</td></tr>
<tr class="memdesc:a96c3848fa91eeb33288096bd0702c437"><td class="mdescLeft">&#160;</td><td class="mdescRight">access an array of objects  <a href="#a96c3848fa91eeb33288096bd0702c437">More...</a><br /></td></tr>
<tr class="separator:a96c3848fa91eeb33288096bd0702c437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73579d54563566749475e8b7a8d7bc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#af73579d54563566749475e8b7a8d7bc5">getarr</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::vector&lt; float &gt; &amp;ref, int start_ix, int num_val) const</td></tr>
<tr class="memdesc:af73579d54563566749475e8b7a8d7bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">access an array  <a href="#af73579d54563566749475e8b7a8d7bc5">More...</a><br /></td></tr>
<tr class="separator:af73579d54563566749475e8b7a8d7bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767f05f9628f7446808b6a08b6f52ed6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a767f05f9628f7446808b6a08b6f52ed6">queryarr</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::vector&lt; float &gt; &amp;ref, int start_ix, int num_val) const</td></tr>
<tr class="separator:a767f05f9628f7446808b6a08b6f52ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe1407891c1447cca1f84a8e85c9029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a9fe1407891c1447cca1f84a8e85c9029">getarr</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::vector&lt; double &gt; &amp;ref, int start_ix, int num_val) const</td></tr>
<tr class="separator:a9fe1407891c1447cca1f84a8e85c9029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8539b8fadfdf7900deabe98c69098aaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a8539b8fadfdf7900deabe98c69098aaa">queryarr</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::vector&lt; double &gt; &amp;ref, int start_ix, int num_val) const</td></tr>
<tr class="separator:a8539b8fadfdf7900deabe98c69098aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508604baf9aa06ed1245bce4738081fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a508604baf9aa06ed1245bce4738081fe">getarr</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::vector&lt; std::string &gt; &amp;ref, int start_ix, int num_val) const</td></tr>
<tr class="separator:a508604baf9aa06ed1245bce4738081fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a9c41be0bc3c459ce622e4c0b9b4d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#aa3a9c41be0bc3c459ce622e4c0b9b4d6">queryarr</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::vector&lt; std::string &gt; &amp;ref, int start_ix, int num_val) const</td></tr>
<tr class="separator:aa3a9c41be0bc3c459ce622e4c0b9b4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278390e9356f99df786a17931b05cba5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a278390e9356f99df786a17931b05cba5">getarr</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::vector&lt; bool &gt; &amp;ref, int start_ix, int num_val) const</td></tr>
<tr class="separator:a278390e9356f99df786a17931b05cba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79dfd08a661df603aa0cb947ce1ad2d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a79dfd08a661df603aa0cb947ce1ad2d6">queryarr</a> (const char *<a class="el" href="Chombo__HDF5Portable_8H.html#aa707aa7ac66e8db8c7c66468df0f32ea">name</a>, std::vector&lt; bool &gt; &amp;ref, int start_ix, int num_val) const</td></tr>
<tr class="separator:a79dfd08a661df603aa0cb947ce1ad2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c8ae7af9fe67a508e1f684439395d0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#a60c8ae7af9fe67a508e1f684439395d0">prefix</a> () const</td></tr>
<tr class="memdesc:a60c8ae7af9fe67a508e1f684439395d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return prefix  <a href="#a60c8ae7af9fe67a508e1f684439395d0">More...</a><br /></td></tr>
<tr class="separator:a60c8ae7af9fe67a508e1f684439395d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af7208bd8e78c6000023adc9ae450c0ce"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParmParse.html#af7208bd8e78c6000023adc9ae450c0ce">PP_entry</a></td></tr>
<tr class="separator:af7208bd8e78c6000023adc9ae450c0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parse Parameters From Command Line and Input Files. </p>
<p>The <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a> class is used to interpret parameters passed in to a program from the command line and an arbitrary collection of input files. The parameters are stored in static table that can be queried by any object of type <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a>. A parameter can be either an "option" (usually specified on the command line) or a "definition". An option is of the form "-&lt;name&gt;" and is stored in the table without the hyphen. A definition is of the form "&lt;name&gt; = &lt;value&gt;&lt;value&gt;...&lt;value&gt;". It is stored in the table as a name, value-list pair.</p>
<p>In the following example, verbose and no_opt are stored in the table as options. niter is a definition with the single integer value 10; name is a definition with the string value "big code" and dx is a definition with the two floating point values 0.5 and 0.75.</p>
<p>prog -verbose -no_opt niter = 10 name = "big code" dx = 0.5 0.75</p>
<p>The <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a> class has two constructors. The first is responsible for building the table and is usually called by the main routine of an application. It has arguments for the command line argc and argv parameters, as well as an optional filename argument for reading definitions from an input file. The table is built by reading the input file first (if it exists) with the command line arguments added to the end of the table. The order of a definition in the table is significant, so command line parameters can be used to override definitions in the input file. A definition of the explicit form: FILE=&lt;filename&gt; is not added to the table but is a directive to include the named file at that point in the table.</p>
<p>The second constructor is generally used by other classes in the code. It permits access to the table via a large collection of query functions. Both constructors have an optional prefix argument that narrows the search to entries in the table with the same prefix. For example, let PlanR be a <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a> object with code prefix "ope". PlanR.get("val",v) will look for an entry in the parameter list of the form: ope.val==</p>
<p>, and will reject all entries not starting with the correct code prefix.</p>
<p>The query functions search the table for definition names that match a given string (and prefix) and return values from the corresponding value list. The values can be returned as ints, Array&lt;int&gt;s, floats, std::vector&lt;float&gt;s, doubles, std::vector&lt;double&gt;s, std::strings, or std::vector&lt;std::sring&gt;s. All values in the table are stored as PP_String objects, but if an int, float, or double is requested, the translation is done automatically. In the previous example, the value of niter could be returned as either an std::string, an int, a double, or a float. The values of dx can be returned as std::strings, floats, or doubles, but the value of name can be returned only as an std::string.</p>
<p>Comments in an input file include all text from a `#' character to the end of the line. Here is a sample input file:</p>
<p>-no_garbage</p>
<p>niter = 100</p>
<p>title = "Double Wammy"</p>
<p>cell_size = 0.5 0.75</p>
<p>plot.var = Density 1 10</p>
<p>plot.var = Energy 5 12</p>
<p>bigarray = 1 2 3 4 5 6 7 8</p>
<p>9 10 11 12</p>
<p>test = apple "boy blue" 10 20 30 40</p>
<p>FILE = prob_file </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a112bc7438b5cb251cbd2fdb332710886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112bc7438b5cb251cbd2fdb332710886">&#9670;&nbsp;</a></span>ParmParse() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParmParse::ParmParse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parfile</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an initial <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a> object from the argc and argv passed in to main(). An error will be signalled if another <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a> object currently exists. If parfile is specified, read the parameters in from that file first and then append those derived from argv to the table. If prefix is specified, load this string as the code prefix for this particular <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a> object. </p>

</div>
</div>
<a id="a6adab381569c0fce8a66af5d94665421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6adab381569c0fce8a66af5d94665421">&#9670;&nbsp;</a></span>ParmParse() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParmParse::ParmParse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an additional <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a> object sharing the same internal table as any other such objects in existence. If prefix is specified, load this string as the code prefix for this particular <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a> object. If there are no other existing objects, this doesn't do anything, and <a class="el" href="classParmParse.html#a1354bd11521da872dbb032377f26f9d3" title="Initialize after calling the default constructor. ">define()</a> must be called before the object can be used. </p>

</div>
</div>
<a id="a967f6fdbdab413dbeac7de43513dce36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967f6fdbdab413dbeac7de43513dce36">&#9670;&nbsp;</a></span>ParmParse() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParmParse::ParmParse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>got sick of typing c_str() </p>

</div>
</div>
<a id="afa4b6164fe6e1fd2e73aed7efb249e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4b6164fe6e1fd2e73aed7efb249e03">&#9670;&nbsp;</a></span>~ParmParse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParmParse::~ParmParse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The destructor. The internal static table will only be deleted if there are no other <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a> objects in existence. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1354bd11521da872dbb032377f26f9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1354bd11521da872dbb032377f26f9d3">&#9670;&nbsp;</a></span>define()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::define </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parfile</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize after calling the default constructor. </p>
<p>Same as the constructor with the same args. </p>

</div>
</div>
<a id="a961167fcaa1cb8c018319298a7d5033f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961167fcaa1cb8c018319298a7d5033f">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ParmParse::contains </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if name is in table. </p>

</div>
</div>
<a id="a029352410364963f7a85fa9f09bebe6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029352410364963f7a85fa9f09bebe6a">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ParmParse::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if name is in table. </p>

</div>
</div>
<a id="a220146c4702c0ffc06dc9d8a00605b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220146c4702c0ffc06dc9d8a00605b35">&#9670;&nbsp;</a></span>countval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::countval </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of values associated with nth occurence of name (prepended with the prefix) in the table. n == -1 implies the last occurence. </p>

<p class="reference">References <a class="el" href="classParmParse.html#af7208bd8e78c6000023adc9ae450c0ce">PP_entry</a>.</p>

</div>
</div>
<a id="aac3e241a4bc7eba217eab34f004f67e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3e241a4bc7eba217eab34f004f67e8">&#9670;&nbsp;</a></span>countname() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::countname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of times the given name (prepended with prefix) appears in the table. </p>

<p class="reference">Referenced by <a class="el" href="classParmParse.html#a9cc02bc16259ded5d8fc506397bdc3be">countname()</a>.</p>

</div>
</div>
<a id="a9cc02bc16259ded5d8fc506397bdc3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc02bc16259ded5d8fc506397bdc3be">&#9670;&nbsp;</a></span>countname() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::countname </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of times the given name (prepended with prefix) appears in the table. </p>

<p class="reference">References <a class="el" href="classParmParse.html#aac3e241a4bc7eba217eab34f004f67e8">countname()</a>.</p>

</div>
</div>
<a id="a362e72bf2e474db7a825f512f09ea7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362e72bf2e474db7a825f512f09ea7f2">&#9670;&nbsp;</a></span>addEntries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::addEntries </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>strEntry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Accessor for private method that adds parameters to the global table (SWS-Tech-X Research) e.g. parmParseObj.addEntries("tst_value = 2") </p>

</div>
</div>
<a id="a7078b192b4d35c4f337e47c0082b19d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7078b192b4d35c4f337e47c0082b19d6">&#9670;&nbsp;</a></span>setVal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::setVal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE&#160;</td>
          <td class="paramname"><em>varVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append input parameter pairs to <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a></p>
<ol type="1">
<li>convert value to string</li>
<li>construct string line syntax for <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a></li>
<li>use special public method in ParmParse.H</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varName</td><td>parameter string name </td></tr>
    <tr><td class="paramname">varVal</td><td>numerical value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11c3b0ce9c95f54033ebf8a803c3f9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c3b0ce9c95f54033ebf8a803c3f9e1">&#9670;&nbsp;</a></span>setStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::setStr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>varVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append input parameter pairs to <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a></p>
<ol type="1">
<li>convert value to string</li>
<li>construct string line syntax for <a class="el" href="classParmParse.html" title="Parse Parameters From Command Line and Input Files. ">ParmParse</a></li>
<li>use special public method in ParmParse.H</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varName</td><td>parameter string name </td></tr>
    <tr><td class="paramname">varVal</td><td>string value type </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="Chombo__CH__HDF5_8H.html#af16952f1060f6c3e4ee26ee8300e75c0">name()</a>.</p>

</div>
</div>
<a id="a88dd5a3e4c26b11e4e02848aae8db5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88dd5a3e4c26b11e4e02848aae8db5aa">&#9670;&nbsp;</a></span>dumpTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::dumpTable </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the contents of the table in ASCII to the ostream. </p>

<p class="reference">Referenced by <a class="el" href="classParmParse.html#a9fe1407891c1447cca1f84a8e85c9029">getarr()</a>.</p>

</div>
</div>
<a id="a3cd67cc36c06ef22ff2f82511aebb775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd67cc36c06ef22ff2f82511aebb775">&#9670;&nbsp;</a></span>get() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ival</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access single object </p>
<p>Get the ival'th value of last occurrence of the requested name. If successful, the value is converted to an int and stored in reference ref. If the name does not exist or ival'th value does not exist, or if the printed representation of the value cannot be converted to an int, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </p>

<p class="reference">Referenced by <a class="el" href="classEBCM_1_1Algorithm__Framework.html#ad547fc352a28bbf330e9244c13232a5a">EBCM::Algorithm_Framework&lt; ebcm_order &gt;::getImplicitFunction()</a>, <a class="el" href="classEBCM_1_1Algorithm__Framework.html#acd30b390188f0fea6cb9c55985c80f74">EBCM::Algorithm_Framework&lt; ebcm_order &gt;::getWorstConditionNumberInfo()</a>, <a class="el" href="classEBCM_1_1Algorithm__Framework.html#a847daf0ec0e5f6d75449a0417ccbd910">EBCM::Algorithm_Framework&lt; ebcm_order &gt;::makeMergedGeometry()</a>, <a class="el" href="classEBCM_1_1Algorithm__Framework_1_1condition__t.html#a48082cb0dcfbfe02083e93ced173a9ae">EBCM::Algorithm_Framework&lt; ebcm_order &gt;::condition_t::poutLatexTable()</a>, <a class="el" href="classEBCM_1_1Algorithm__Framework.html#aa2281e5dc75f60e8358a5edf08351ab9">EBCM::Algorithm_Framework&lt; ebcm_order &gt;::run_hoeb_petsc_tests()</a>, and <a class="el" href="classEBCM_1_1PETSc__Framework.html#a4de5acd888affa4f66c69b2f0d374a91">EBCM::PETSc_Framework&lt; ebcm_order &gt;::run_hoeb_truncation_tests()</a>.</p>

</div>
</div>
<a id="ab20debc979cb3423e95a47456144632b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20debc979cb3423e95a47456144632b">&#9670;&nbsp;</a></span>query() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ival</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the ival'th value of last occurrence of the requested name. If successful, the value is converted to an int and stored in reference ref. Returns 1 if successful. Returns 0 if the name does not exist. If ival'th value does not exist, or if the printed representation of the value cannot be converted to an int, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </p>

<p class="reference">Referenced by <a class="el" href="classGeometryService.html#aff2684fe22a4ec9de5b38df1e166b495">GeometryService&lt; order &gt;::generateGrids()</a>.</p>

</div>
</div>
<a id="ab0e3ae744edfdae799c323cd9fa535fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e3ae744edfdae799c323cd9fa535fa">&#9670;&nbsp;</a></span>get() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ival</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access single object </p>
<p>Get the ival'th value of last occurrence of the requested name. If successful, the value is converted to a n unsigned long and stored in reference ref. If the name does not exist or ival'th value does not exist, or if the printed representation of the value cannot be converted to an int, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </p>

</div>
</div>
<a id="a4ad49a66379d779de65ec5b5a369d260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad49a66379d779de65ec5b5a369d260">&#9670;&nbsp;</a></span>query() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ival</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the ival'th value of last occurrence of the requested name. If successful, the value is converted to an unsigned long and stored in reference ref. Returns 1 if successful. Returns 0 if the name does not exist. If ival'th value does not exist, or if the printed representation of the value cannot be converted to an int, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </p>

</div>
</div>
<a id="a78e8996d798a3e595802d7c865b47d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e8996d798a3e595802d7c865b47d3d">&#9670;&nbsp;</a></span>get() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ival</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the ival'th value of last occurrence of the requested name. If successful, the value is converted to a float and stored in reference ref. If the name does not exist or ival'th value does not exist, or if the printed representation of the value cannot be converted to a float, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </p>

</div>
</div>
<a id="a164719e0ea3328d2b47c1da70e926975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164719e0ea3328d2b47c1da70e926975">&#9670;&nbsp;</a></span>query() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ival</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the ival'th value of last occurrence of the requested name. If successful, the value is converted to a float and stored in reference ref. Returns 1 if successful. Returns 0 if the name does not exist. If ival'th value does not exist, or if the printed representation of the value cannot be converted to a float, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </p>

</div>
</div>
<a id="a6a235d4051cfc27d34fe9619658f80ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a235d4051cfc27d34fe9619658f80ca">&#9670;&nbsp;</a></span>get() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ival</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the ival'th value of last occurrence of the requested name. If successful, the value is converted to a double and stored in reference ref. If the name does not exist or ival'th value does not exist, or if the printed representation of the value cannot be converted to a double, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </p>

</div>
</div>
<a id="a76912c5c14c363ad037eefbdef990c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76912c5c14c363ad037eefbdef990c5a">&#9670;&nbsp;</a></span>query() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ival</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the ival'th value of last occurrence of the requested name. If successful, the value is converted to a double and stored in reference ref. Returns 1 if successful. Returns 0 if the name does not exist. If ival'th value does not exist, or if the printed representation of the value cannot be converted to a double, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </p>

</div>
</div>
<a id="af84d76469c5ad1371270f460858ebcdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84d76469c5ad1371270f460858ebcdc">&#9670;&nbsp;</a></span>get() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ival</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ival'th value of last occurrence of the requested name. </p>
<p>Get the ival'th value of last occurrence of the requested name. If successful, the value is converted to a string and stored in reference ref. If the name does not exist or ival'th value does not exist, or if the printed representation of the value cannot be converted to a string, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </p>

</div>
</div>
<a id="ac0e557349f66d11a6d44fdbd0b5f3756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e557349f66d11a6d44fdbd0b5f3756">&#9670;&nbsp;</a></span>query() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ival</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ival'th value of last occurrence of the requested name. </p>
<p>Get the ival'th value of last occurrence of the requested name. If successful, the value is converted to a string and stored in reference ref. Returns 1 if successful. Returns 0 if the name does not exist. If ival'th value does not exist, or if the printed representation of the value cannot be converted to a string, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </p>

</div>
</div>
<a id="ad8ea98d11d58450efc84d69eccd17f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ea98d11d58450efc84d69eccd17f81">&#9670;&nbsp;</a></span>get() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ival</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ival'th value of last occurrence of the requested name. </p>
<p>Get the ival'th value of last occurrence of the requested name. If successful, the value is converted to a bool and stored in reference ref. If the name does not exist or ival'th value does not exist, or if the printed representation of the value cannot be converted to a bool, an error message is output and the program halts. Valid representations of bool are "true" and "false" (case is ignored), and numeric values 1 (=true) and 0 (=false). Note that ival == 0 is the first value in the list. </p>

</div>
</div>
<a id="ab76e4c10ab679ae25df9d3c55054f1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76e4c10ab679ae25df9d3c55054f1fd">&#9670;&nbsp;</a></span>query() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ival</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ival'th value of last occurrence of the requested name. </p>
<p>Get the ival'th value of last occurrence of the requested name. If successful, the value is converted to a bool and stored in reference ref. Returns 1 if successful. Returns 0 if the name does not exist. If ival'th value does not exist, or if the printed representation of the value cannot be converted to a bool, an error message is output and the program halts. Valid representations of bool are "true" and "false" (case is ignored), and numeric values 1 (=true) and 0 (=false). Note that ival == 0 is the first value in the list. </p>

</div>
</div>
<a id="a0bfb577917bc17e952fa0c64608fa688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfb577917bc17e952fa0c64608fa688">&#9670;&nbsp;</a></span>getarr() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::getarr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access an array of objects </p>
<p>Gets a std::vector&lt;int&gt; of num_val values from last occurrence of given name. If successful, the values are converted to an int and stored in the std::vector&lt;int&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;int&gt;[0], std::vector&lt;int&gt;[1] holds start_ix+1, etc. If there are fewer than start_ix + num_val values associated with the last occurrence, or if some of the values cannot be converted to an int, an error message is reported and the program halts. </p>

<p class="reference">Referenced by <a class="el" href="classParmParse.html#af73579d54563566749475e8b7a8d7bc5">getarr()</a>, and <a class="el" href="classEBCM_1_1Algorithm__Framework.html#ad547fc352a28bbf330e9244c13232a5a">EBCM::Algorithm_Framework&lt; ebcm_order &gt;::getImplicitFunction()</a>.</p>

</div>
</div>
<a id="a4bd5b0a97ebf1ed742a4e5d1d6b981aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd5b0a97ebf1ed742a4e5d1d6b981aa">&#9670;&nbsp;</a></span>queryarr() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::queryarr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access an array of objects </p>
<p>Gets a std::vector&lt;int&gt; of num_val values from last occurrence of given name. If successful, the values are converted to an int and stored in the std::vector&lt;int&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;int&gt;[0], std::vector&lt;int&gt;[1] holds start_ix+1, etc. Returns 0 if the name does not exist. If there are fewer than start_ix + num_val values associated with the last occurrence, or if some of the values cannot be converted to an int, an error message is reported and the program halts. </p>

<p class="reference">Referenced by <a class="el" href="classParmParse.html#a9fe1407891c1447cca1f84a8e85c9029">getarr()</a>, and <a class="el" href="classParmParse.html#a767f05f9628f7446808b6a08b6f52ed6">queryarr()</a>.</p>

</div>
</div>
<a id="a45f68fc1255e45095978ab54eb726c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f68fc1255e45095978ab54eb726c9f">&#9670;&nbsp;</a></span>getarr() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::getarr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>access an array of objects </p>
<p>Gets a std::vector&lt;unsigned long&gt; of num_val values from last occurrence of given name. If successful, the values are converted to an unsigned long and stored in the std::vector&lt;unsigned long&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;unsigned long&gt;[0], std::vector&lt;unsigned long&gt;[1] holds start_ix+1, etc. If there are fewer than start_ix + num_val values associated with the last occurrence, or if some of the values cannot be converted to an unsigned long, an error message is reported and the program halts. </p>

</div>
</div>
<a id="a96c3848fa91eeb33288096bd0702c437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c3848fa91eeb33288096bd0702c437">&#9670;&nbsp;</a></span>queryarr() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::queryarr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>access an array of objects </p>
<p>Gets a std::vector&lt;unsigned long&gt; of num_val values from last occurrence of given name. If successful, the values are converted to an unsigned long and stored in the std::vector&lt;unsigned long&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;unsigned long&gt;[0], std::vector&lt;unsigned long&gt;[1] holds start_ix+1, etc. Returns 0 if the name does not exist. If there are fewer than start_ix + num_val values associated with the last occurrence, or if some of the values cannot be converted to an unsigned long, an error message is reported and the program halts. </p>

</div>
</div>
<a id="af73579d54563566749475e8b7a8d7bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73579d54563566749475e8b7a8d7bc5">&#9670;&nbsp;</a></span>getarr() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::getarr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access an array </p>
<p>Gets a std::vector&lt;float&gt; of num_val values from last occurrence of given name. If successful, the values are converted to a float and stored in the std::vector&lt;float&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;float&gt;[0], std::vector&lt;float&gt;[1] holds start_ix+1, etc. If there are fewer than start_ix + num_val values associated with the last occurrence, or if some of the values cannot be converted to a float, an error message is reported and the program halts. </p>

<p class="reference">References <a class="el" href="classParmParse.html#a0bfb577917bc17e952fa0c64608fa688">getarr()</a>.</p>

</div>
</div>
<a id="a767f05f9628f7446808b6a08b6f52ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767f05f9628f7446808b6a08b6f52ed6">&#9670;&nbsp;</a></span>queryarr() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::queryarr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a std::vector&lt;float&gt; of num_val values from last occurrence of given name. If successful, the values are converted to a float and stored in the std::vector&lt;float&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;float&gt;[0], std::vector&lt;float&gt;[1] holds start_ix+1, etc. Returns 0 if the name does not exist. If there are fewer than start_ix + num_val values associated with the last occurrence, or if some of the values cannot be converted to a float, an error message is reported and the program halts. </p>

<p class="reference">References <a class="el" href="classParmParse.html#a4bd5b0a97ebf1ed742a4e5d1d6b981aa">queryarr()</a>.</p>

</div>
</div>
<a id="a9fe1407891c1447cca1f84a8e85c9029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe1407891c1447cca1f84a8e85c9029">&#9670;&nbsp;</a></span>getarr() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::getarr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a std::vector&lt;double&gt; of num_val values from last occurrence of given name. If successful, the values are converted to a double and stored in the std::vector&lt;double&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;double&gt;[0], std::vector&lt;double&gt;[1] holds start_ix+1, etc. If there are fewer than start_ix + num_val values associated with the last occurrence, or if some of the values cannot be converted to a double, an error message is reported and the program halts. </p>

<p class="reference">References <a class="el" href="classMayDay.html#a5481795e92cd5d19b53c6b37c7a2a038">MayDay::Abort()</a>, <a class="el" href="classParmParse.html#a88dd5a3e4c26b11e4e02848aae8db5aa">dumpTable()</a>, and <a class="el" href="classParmParse.html#a4bd5b0a97ebf1ed742a4e5d1d6b981aa">queryarr()</a>.</p>

</div>
</div>
<a id="a8539b8fadfdf7900deabe98c69098aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8539b8fadfdf7900deabe98c69098aaa">&#9670;&nbsp;</a></span>queryarr() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::queryarr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a std::vector&lt;double&gt; of num_val values from last occurrence of given name. If successful, the values are converted to a double and stored in the std::vector&lt;double&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;double&gt;[0], std::vector&lt;double&gt;[1] holds start_ix+1, etc. Returns 0 if the name does not exist. If there are fewer than start_ix + num_val values associated with the last occurrence, or if some of the values cannot be converted to a double, an error message is reported and the program halts. </p>

<p class="reference">References <a class="el" href="classParmParse.html#a4bd5b0a97ebf1ed742a4e5d1d6b981aa">queryarr()</a>.</p>

</div>
</div>
<a id="a508604baf9aa06ed1245bce4738081fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508604baf9aa06ed1245bce4738081fe">&#9670;&nbsp;</a></span>getarr() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::getarr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a std::vector&lt;string&gt; of num_val values from last occurrence of given name. If successful, the values are converted to a string and stored in the std::vector&lt;string&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;string&gt;[0], std::vector&lt;string&gt;[1] holds start_ix+1, etc. If there are fewer than start_ix + num_val values associated with the last occurrence, or if some of the values cannot be converted to a string, an error message is reported and the program halts. </p>

<p class="reference">References <a class="el" href="classParmParse.html#a0bfb577917bc17e952fa0c64608fa688">getarr()</a>.</p>

</div>
</div>
<a id="aa3a9c41be0bc3c459ce622e4c0b9b4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a9c41be0bc3c459ce622e4c0b9b4d6">&#9670;&nbsp;</a></span>queryarr() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::queryarr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a std::vector&lt;string&gt; of num_val values from last occurrence of given name. If successful, the values are converted to a string and stored in the std::vector&lt;string&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;string&gt;[0], std::vector&lt;string&gt;[1] holds start_ix+1, etc. Returns 0 if the name does not exist. If there are fewer than start_ix + num_val values associated with the last occurrence, or if some of the values cannot be converted to a string, an error message is reported and the program halts. </p>

<p class="reference">References <a class="el" href="classParmParse.html#a4bd5b0a97ebf1ed742a4e5d1d6b981aa">queryarr()</a>.</p>

</div>
</div>
<a id="a278390e9356f99df786a17931b05cba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278390e9356f99df786a17931b05cba5">&#9670;&nbsp;</a></span>getarr() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParmParse::getarr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a std::vector&lt;bool&gt; of num_val values from last occurrence of given name. If successful, the values are converted to a bool and stored in the std::vector&lt;bool&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;bool&gt;[0], std::vector&lt;bool&gt;[1] holds start_ix+1, etc. If there are fewer than start_ix + num_val values associated with the last occurrence, or if some of the values cannot be converted to a bool, an error message is reported and the program halts. </p>

<p class="reference">References <a class="el" href="classParmParse.html#a0bfb577917bc17e952fa0c64608fa688">getarr()</a>.</p>

</div>
</div>
<a id="a79dfd08a661df603aa0cb947ce1ad2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79dfd08a661df603aa0cb947ce1ad2d6">&#9670;&nbsp;</a></span>queryarr() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParmParse::queryarr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a std::vector&lt;bool&gt; of num_val values from last occurrence of given name. If successful, the values are converted to a bool and stored in the std::vector&lt;bool&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;bool&gt;[0], std::vector&lt;bool&gt;[1] holds start_ix+1, etc. Returns 0 if the name does not exist. If there are fewer than start_ix + num_val values associated with the last occurrence, or if some of the values cannot be converted to a bool, an error message is reported and the program halts. </p>

<p class="reference">References <a class="el" href="classParmParse.html#a4bd5b0a97ebf1ed742a4e5d1d6b981aa">queryarr()</a>.</p>

</div>
</div>
<a id="a60c8ae7af9fe67a508e1f684439395d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c8ae7af9fe67a508e1f684439395d0">&#9670;&nbsp;</a></span>prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* ParmParse::prefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return prefix </p>

<p class="reference">References <a class="el" href="Chombo__CH__HDF5_8H.html#af16952f1060f6c3e4ee26ee8300e75c0">name()</a>, and <a class="el" href="classParmParse.html#af7208bd8e78c6000023adc9ae450c0ce">PP_entry</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af7208bd8e78c6000023adc9ae450c0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7208bd8e78c6000023adc9ae450c0ce">&#9670;&nbsp;</a></span>PP_entry</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class PP_entry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classParmParse.html#a220146c4702c0ffc06dc9d8a00605b35">countval()</a>, and <a class="el" href="classParmParse.html#a60c8ae7af9fe67a508e1f684439395d0">prefix()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Chombo__ParmParse_8H_source.html">Chombo_ParmParse.H</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
